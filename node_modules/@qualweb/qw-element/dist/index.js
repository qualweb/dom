'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.QWElement = void 0;
class QWElement {
    constructor(element) {
        this.element = element;
    }
    elementHasAttribute(attribute) {
        return this.element.getAttributeNames().includes(attribute);
    }
    elementHasAttributes() {
        return this.element.getAttributeNames().length > 0;
    }
    elementHasChild(childName) {
        for (const child of this.element.children) {
            if (child.tagName.toLowerCase() === childName.toLowerCase()) {
                return true;
            }
        }
        return false;
    }
    elementHasChidren() {
        return this.element.children.length > 0;
    }
    elementHasParent(parent) {
        const parentElement = this.element['parentElement'];
        return parentElement ? parentElement['tagName'].toLowerCase() === parent.toLowerCase() : false;
    }
    getElementAttribute(attribute) {
        return this.element.getAttribute(attribute);
    }
    getElementAttributes() {
        const attributes = {};
        for (const attr of this.element.getAttributeNames() || []) {
            attributes[attr] = this.element.getAttribute(attr);
        }
        return attributes;
    }
    getElementAttributesName() {
        return this.element.getAttributeNames();
    }
    getElementChildren() {
        const selector = this.getElementSelector();
        let treeSelector = this.getTreeSelector();
        let elements = this.element.querySelectorAll(selector + ' > *' + treeSelector);
        let qwList = [];
        for (let element of elements) {
            qwList.push(new QWElement(element));
        }
        return qwList;
    }
    getTreeSelector() {
        let atribute = this.getElementAttribute("shadowTree");
        let result = ":not([shadowTree])";
        if (atribute !== null) {
            result = `[shadowTree="${atribute}"]`;
        }
        return result;
    }
    getElementChildTextContent(childName) {
        for (const child of this.element.children || []) {
            if (child.tagName.toLowerCase() === childName.toLowerCase()) {
                return child['textContent'] || undefined;
            }
        }
        return undefined;
    }
    getElementHtmlCode(withText, fullElement) {
        const clonedElem = this.element.cloneNode(true);
        if (fullElement) {
            return clonedElem.outerHTML;
        }
        else if (withText) {
            const text = clonedElem['text'];
            clonedElem.innerHTML = text !== undefined ? text : '';
            return clonedElem.outerHTML;
        }
        else {
            clonedElem.innerHTML = '';
            return clonedElem.outerHTML;
        }
    }
    getElement(selector) {
        let element = this.element.querySelector(selector);
        return this.converElementToQWElement(element);
    }
    converElementToQWElement(element) {
        if (element)
            return new QWElement(element);
        else
            return null;
    }
    converElementsToQWElement(elements) {
        let qwList = [];
        for (let element of elements) {
            qwList.push(new QWElement(element));
        }
        return qwList;
    }
    getElements(selector) {
        return this.converElementsToQWElement(this.element.querySelectorAll(selector));
    }
    getElementNextSibling() {
        return this.converElementToQWElement(this.element.nextElementSibling);
    }
    getElementParent() {
        return this.converElementToQWElement(this.element.parentElement);
    }
    getElementPreviousSibling() {
        return this.converElementToQWElement(this.element.previousElementSibling);
    }
    getElementProperty(property) {
        let propertyValue = this.element[property];
        return propertyValue === null ? "" : propertyValue;
    }
    getElementSelector() {
        if (this.element.tagName.toLowerCase() === 'html') {
            return 'html';
        }
        else if (this.element.tagName.toLowerCase() === 'head') {
            return 'html > head';
        }
        else if (this.element.tagName.toLowerCase() === 'body') {
            return 'html > body';
        }
        let selector = 'html > ';
        let parents = new Array();
        let parent = this.element['parentElement'];
        while (parent && parent.tagName.toLowerCase() !== 'html') {
            parents.unshift(this.getSelfLocationInParent(parent));
            parent = parent['parentElement'];
        }
        selector += parents.join(' > ');
        selector += ' > ' + this.getSelfLocationInParent(this.element);
        return selector;
    }
    getSelfLocationInParent(element) {
        let selector = '';
        if (element.tagName.toLowerCase() === 'body' || element.tagName.toLowerCase() === 'head') {
            return element.tagName.toLowerCase();
        }
        let sameEleCount = 0;
        let prev = element.previousElementSibling;
        while (prev) {
            if (prev.tagName.toLowerCase() === element.tagName.toLowerCase()) {
                sameEleCount++;
            }
            prev = prev.previousElementSibling;
        }
        selector += `${element.tagName.toLowerCase()}:nth-of-type(${sameEleCount + 1})`;
        return selector;
    }
    getElementStyleProperty(property, pseudoStyle) {
        const styles = getComputedStyle(this.element, pseudoStyle);
        return styles.getPropertyValue(property);
    }
    getElementTagName() {
        return this.element['tagName'].toLowerCase();
    }
    getElementText() {
        let text = this.element.textContent;
        if (text === null)
            text = "";
        return text;
    }
    getElementType() {
        return this.element['nodeType'] === 1 ? 'tag' : this.element['nodeType'] === 2 ? 'attribute' : this.element['nodeType'] === 3 ? 'text' : 'comment';
    }
    getNumberOfSiblingsWithTheSameTag() {
        let aCount = 1;
        let nextSibling = this.element['nextElementSibling'];
        while (nextSibling) {
            if (nextSibling['tagName'].toLowerCase() === 'a') {
                aCount++;
            }
            nextSibling = nextSibling['nextElementSibling'];
        }
        return aCount;
    }
    setElementAttribute(attribute, value) {
        this.element.setAttribute(attribute, value);
    }
    concatANames(aNames) {
        let chidlren = this.element.childNodes;
        let result = "";
        let textContent;
        let i = 0;
        let counter = 0;
        for (let child of chidlren) {
            textContent = child.textContent;
            if (child.nodeType === 3 && !!textContent && textContent.trim() !== "") {
                result = result + (counter === 0 ? "" : " ") + textContent.trim();
                counter++;
            }
            else if (child.nodeType === 1) {
                result = result + (counter > 0 && !!aNames[i] ? " " : "") + aNames[i];
                i++;
            }
        }
        if (!result) {
            result = "";
        }
        return result;
    }
    isOffScreen() {
        let scrollHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
        let scrollWidth = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientHeight);
        let bounding = this.element.getBoundingClientRect();
        let left = bounding.left;
        let right = bounding.right;
        let bottom = bounding.bottom;
        let top = bounding.top;
        let noParentScrollTop = this.noParentScrolled(this.element, bottom);
        return left > scrollWidth || right < 0 || bottom < 0 && noParentScrollTop || top > scrollHeight || right === 0 && left === 0;
    }
    isElementHTMLElement() {
        return this.element instanceof HTMLElement;
    }
    getContentFrame() {
        let page;
        if (this.getElementTagName() === "iframe") {
            let element = this.element;
            let contentWindow = element.contentWindow;
            if (contentWindow) {
                page = contentWindow.document;
            }
        }
        return page;
    }
    elementHasTextNode() {
        if (this.element.firstChild !== null)
            return this.element.firstChild.nodeType === 3;
        else
            return false;
    }
    noParentScrolled(element, offset) {
        element = element['parentElement'];
        while (element && element.nodeName.toLowerCase() !== 'html') {
            if (element.scrollTop) {
                offset += element.scrollTop;
                if (offset >= 0) {
                    return false;
                }
            }
            element = element.parentElement;
        }
        return true;
    }
    focusElement() {
        let htmlElement = this.element;
        htmlElement.focus();
    }
}
exports.QWElement = QWElement;
